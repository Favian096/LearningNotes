# 软件工程



## 基本概述

#### 软件及其特点

---

- ###### 软件的定义: 程序 + 文档(方法/规则) + 数据

- ###### 软件的特点: 

  - 是**无形的、不可见**的逻辑实体
  - 是**设计开发**的，而不是生产制造的
  - 在使用过程中**没有磨损、老化**的问题
  - 需要具备**演化**能力
  - 是**定制**开发的
  - 是**复杂的**
  - **开发成本高**
  - 易于**复制**
  - **质量要求较高**
  - 开发与运行都离不开相关的**计算机系统环境**
  - 开发工作牵涉到许多**社会因素**






#### 四个阶段和危机

---

- ###### **个人程序**(20世纪60年代中期以前)

  - 为某个具体的应用和特定的硬件而定制, 规模较小以个人或小组方式进行。
  
-  ###### **软件作坊**(20世纪60年代中期-70年代中期, 出现若干高级语言)

  - 由专门软件开发组织开发, 沿用早期个体化软件开发方法
  
- ###### **软件工程**(20世纪70年代中期-80年代中期)

  - 倡导以工程的原理、原则和方法进行软件的开发，以解决软件危机。
  
- ###### **第四阶段**(20世纪80年代中期-现在)




- ###### 软件危机

  - 软件危机是指在计算机软件的**开发和维护**过程中所遇到的一系列严重问题。
  - 软件危机包含下述两方面的问题：
    -  如何开发软件，以满足对软件日益增长的需求；
    -  如何维护数量不断膨胀的已有软件。
  - 软件危机的典型表现: 
    - 对软件开发成本和进度的估计常常很不准确
    - 用户对“已完成的”软件系统不满意的现象经常发生
    - 软件产品的质量往往靠不住
    - 软件常常是不可维护的(**周期长、成本高、质量差、维护困难**)
    - 软件通常没有适当的文档资料
    - 软件成本在计算机系统总成本中所占的比例逐年上升
    - 软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势
  - 软件危机产生的原因：
    - 随着软件规模的增大，其复杂性往往呈指数级升高
    - 软件开发人员与用户交流存在障碍
    - 缺乏软件开发的经验和有关软件开发数据的积累，使得开发工作的计划很难制订
    - 缺少有效的软件评测手段，提交用户的软件质量差
    - 软件开发过程不规范，软件难以维护
  - 消除软件危机的途径：
    - 首先应该对计算机软件有一个正确的认识
    - 充分认识到软件开发不是某种个体劳动的神秘技巧 
    - 而应该是各类人员协同配合，共同完成的工程项目
    - 推广使用在实践中总结出来的开发软件的成功的技术和方法，并且研究探索更好更有效的技术和方法
    - 应该开发和使用更好的软件工具





#### 软件工程定义

---

- ###### 基本概述: 

  > 软件工程是指导计算机软件开发和维护的一门工程学科。采用工程的概念、原理、技术和方法来开发与维护软件，把经过时间考验而证明正确的管理技术和当前能够得到的最好的技术方法结合起来，以经济地开发出高质量的软件并有效地维护它，这就是软件工程。

- ###### 软件工程的定义:

  - 软件工程就是为了经济地获得可靠的且能在实际机器上有效地运行的软件，而建立和使用完善的工程原理。
  -  ①把系统的、规范的、可度量的途径应用于软件开发、运行和维护过程，也就是把工程应用于软件； ②研究①中提到的途径。

- ###### 软件工程的本质：

  |      是什么      |       不是什么       |
  | :--------------: | :------------------: |
  |   如何开发软件   |     如何使用软件     |
  |  较大规模的软件  |    小型、微型软件    |
  |     工程方法     | 作坊、个体、科研方法 |
  |     规范过程     |       混乱过程       |
  | 高质量、高可信度 |    低质量、不可信    |
  |     按时完成     |       拖延时间       |
  |     预算受控     |       超出预算       |






#### 软件工程的目标

---

- ###### 生产具有正确性、可用性以及开销合宜的产品：

  - 正确性：
    意指软件产品达到预期功能的程度；
  - 可用性：
    意指软件基本结构、实现及文档为用户可用的程度：
  - 开销合宜：
    指软件开发、运行的整个开销满足用户要求的程度。





#### 软件工程基本原理

---

> - 用分阶段的生命周期计划严格管理；
> - 坚持进行阶段评审；
> - 实行严格的产品控制；
> - 采用现代程序设计技术；
> - 结果应能清楚地审查；
> - 开发小组的人员应该少而精；
> - 承认不断改进软件工程实践的必要性。





#### 软件工程方法学

---

- ###### 方法: 

  > 完成软件开发的各项任务的技术方法，回答“怎样做”的问题

- ###### 工具: 

  > 为运用方法而提供的自动的或半自动的软件工程支撑环境

- ###### 过程: 

  > 为了获得高质量的软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤

  

---

- ###### 将世界视为过程:

  - 世界由一个个相互关联的小系统组成；
  - 每个小系统都有明确的开始和明确的结束，开始和结束之间有着严谨的因果关系。

- ###### 传统方法学:

  - 也称为生命周期方法学或结构化范型, 采用**结构化技术**(结构化分析、结构化设计和结构化实现)
  - 传统方法学把软件生命周期的全过程依次划分为若干个阶段，然后顺序地完成每个阶段的任务。
  - 每个阶段的开始和结束都有严格标准，对于任何两个相邻的阶段而言，前一阶段的结束标准就是后一阶段的开始标准。
  - 采用生命周期方法学可以大大提高软件开发的成功率，软件开发的生产率也能明显提高。
  - 目前，传统方法学仍然是人们在开发软件时使用得十分广泛的软件工程方法学
  - 传统方法学在需求复杂度较低的时候非常管用，却在面对如今这个复杂的世界显得无能为力。
  - 传统方法学并非不正确，只是因为构成一个系统的因素太多，要把所有可能的因素都考虑到，把所有因素的因果关系都分析清楚，再把这个过程模拟出来实在是太困难了。



---

- ###### 将世界视为对象：

  - 世界由一个个相互独立的对象组成；
  - 对象相互之间并无因果关系；
  - 只有在某个外部力量的驱动下，对象之间才会依据某种规律相互传递信息。

- ###### 面向对象方法学基本原则：

  > 尽量模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界、解决问题的方法与过程，从而使描述问题的问题空间(也称为问题域)与实现解法的解空间(也称为求解域)在结构上尽可能一致。
  
- ###### 面向对象方法学四个要点：

  - 把对象(object)作为融合了数据及在数据上的操作行为的统一的软件构件
  -  把所有对象都划分成类(class)
  -  按照父类与子类的关系，把若干个相关类组成一个层次结构的系统
  - 对象彼此间仅能通过发送消息互相联系

- ###### 面向对象方法学的优点：

  - 尽量模拟人类习惯的思维方式，使开发软件的方法与过程尽可能接近人类认识世界、解决问题的方法与过程
  - 降低了软件产品的复杂性，提高了软件的可理解性，简化了软件的开发和维护工作
  - 面向对象方法特有的继承性和多态性，进一步提高了面向对象软件的可重用性



---

- ###### 面向对象方法与传统方法的不同：

  - 面向对象方法不再把世界看做一个紧密关联的系统，而是看成一些相互独立的离散的小零件，这些零件依据某种规则组织起来。完成一个特定的功能。
  - 过程并非这个世界的本源，过程是由通过特定规则组织起来的一些对象“表现”出来的，原始的对象既独立于过程，也独立于组装规则。



## 软件的生命周期

- ###### 软件生命周期： 

  - 软件从产生、发展到成熟、直至衰亡为止
  - 软件生命周期由软件定义、软件开发和运行维护(也称为软件维护)3个时期组成，每个时期又进一步划分成若干个阶段。

- ###### 软件生命周期分8个阶段：

  >**软件定义**
  >
  >1. 问题定义；
  >2. 可行性研究；
  >3. 需求分析；
  
  >**软件开发**
  >
  >4. 总体设计；
  >5. 详细设计；
  >6. 编码和单元测试（实现）；
  >7. 综合测试；
  
  >**运行维护**
  >
  >8. 软件维护。
  



#### 问题定义

---

- 确定“要解决的问题是什么”；
- 通过对客户的访问调查，系统分析员扼要地写出关于问题性质、工程目标和工程规模的书面报告，经过讨论和必要的修改之后这份报告应该得到客户的确认。



#### 可行性研究

---

- 确定“有行得通解决方法？粗略计划”；
- 可行性研究应该比较简短；
- 可行性研究的结果是客户作出是否继续进行这项工程的决定的重要依据；
- 可行性研究报告。



#### 需求分析

---

- 确定“为了解决这个问题，目标系统必须做什么？”；
- 需求分析是完整、准确、清晰、具体。；
- 需求规格说明书。



#### 总体设计

---

- 确定“概括地说，应该怎样实现目标系统？”；
- 根据需求设计方案；分析推荐最佳方案；设计软件结构等；
- 总体设计说明书。



#### 详细设计

---

- 确定“应该怎样具体地实现目标系统？”；
- 设计每个模块的算法和数据结构；
- 详细设计说明书。





#### 编码和单元测试

---

- 写出正确的容易理解、容易维护的程序模块；
- 选择语言、工具翻译详细设计结果、测试模块；
- 程序清单、单元测试报告。





#### 综合测试

---

- 通过各种类型的测试（及相应的调试）使软件达到预定的要求；
- 集成测试：将经过单元测试模块组装起来进行测试；
- 验收测试：由用户按需求规格说明书规定进行测试；
- 测试报告：测试计划、测试方案、测试结果。





#### 软件维护

> **系统维护占据工程的很大一部分成本。**

---

- 通过必要维护活动使系统持久满足用户要求；
- 改正性维护：软件运行过程中发现错误，进行维护；
- 适应性维护：软件运行软硬件环境变化，进行的维护；
- 完善性维护：用户要求改进或扩充软件，进行的维护；
- 预防性维护：为将来的维护作准备。





## 软件过程模型



#### 软件过程

---

###### 软件过程: 

- 软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。
- 软件过程描述为了开发出客户需要的软件，什么人（who）、在什么时候（when）、做什么事（what）以及怎样（how）做这些事以实现某一个特定的具体目标。

###### 软件过程模型：

- 通常使用生命周期模型简洁地描述软件过程。
- 实际从事软件开发工作时，软件规模、类型、开发环境及技术方法等因素会影响到阶段划分，及各阶段的执行顺序，形成不同生存周期模型，又称过程模型。





#### 瀑布模型

---
> 传统的瀑布模型: 
>
> 一直是唯一被广泛采用的生命周期模型，现在它仍然是软件工程中应用得最广泛的过程模型。
>
> 实际的瀑布模型: 
>
> 1. 图中实线箭头表示开发过程，虚线箭头表示维护过程；
> 2. 当在后面阶段发现前面阶段的错误时，需要沿图中左侧的反馈线返回前面的阶段，修正前面阶段的产品之后再回来继续完成后面阶段的任务。
>
> ![](./Assets/WaterfallModel.png)

- ###### 瀑布模型的特点: 

  - 阶段间具有顺序性和依赖性：
    ①必须等前一阶段的工作完成之后，才能开始后一阶段的工作；
    ②前一阶段的输出文档就是后一阶段的输入文档，因此，只有前一阶段的输出文档正确，后一阶段的工作才能获得正确的结果。
  - 推迟实现的观点：
    瀑布模型在编码之前设置了系统分析与系统设计的各个阶段，分析与设计阶段的基本任务规定，在这两个阶段主要考虑目标系统的逻辑模型，不涉及软件的
    物理实现。
  - 质量保证的观点：
    为了保证所开发的软件的质量，在瀑布模型的每个阶段都应坚持两个重要做法。
    ①每个阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。
    ②每个阶段结束前都要对所完成的文档进行评审，以便尽早发现问题，改正错误。

- ###### 瀑布模型的优点: 

  - 可强迫开发人员采用规范的方法（例如，结构化技术）；
  - 严格地规定了每个阶段必须提交的文档；
  - 要求每个阶段交出的所有产品都必须经过质量保证小组的仔细验证。

- ###### 瀑布模型的缺点: 

  - 客户必须能够完整、正确和清晰地表达他们的需求，开发人员一开始就必须理解需求；
  - 缺乏灵活性。一旦软件需求存在偏差，就会导致开发出的软件产品不能满足用户的实际需求；
  - 在一个项目的早期阶段，过分地强调了基线和里程碑处的文档，可能要花费更多的时间，建立一些用处不大的文档；
  - 直到项目结束之前，都不能演示系统的能力，增加了项目的风险。

- ###### 瀑布模型的适用情况: 

  - 需求已被很好地定义和理解；
  - 过程设计人员也很清楚：开发组织非常熟悉为实现这一模型所需要的过程。





#### 快速原型模型

---

> 快速原型是快速建立起来的可以在计算机上运行的程序，它所能完成的功能往往是最终产品能完成的功能的一个子集。
>
> ![](./Assets/RapidPrototypingModel.png)

- ###### 能基本上做到线性顺序开发的主要原因如下: 

  - 原型系统已经通过与用户交互而得到验证，据此产生的规格说明文档正确地描述了用户需求，因此，在开发过程的后续阶段不会因为发现了规格说明文档的错误而进行较大的返工。
  - 开发人员通过建立原型系统已经学到了许多东西（至少知道了“系统不应该做什么，以及怎样不去做不应该做的事情” ），因此，在设计和编码阶段发生错误的可能性也比较小，这自然减少了在后续阶段需要改正前面阶段所犯错误的可能性。

- ###### 快速原型模型的适用情况: 

  - 需求获取困难以及后期软件需求变更；
  - 快速：加速软件开发过程，节约软件开发成本。





#### 喷泉模型

---

> - 图中代表不同阶段的圆圈相互重叠，这明确表示两个活动之间存在交迭；
> - 图中在一个阶段内的向下箭头代表该阶段内的迭代（或求精）
> - 图中较小的圆圈代表维护，圆圈较小象征着采用了面向对象范型之后维护时间缩短了。
>
> ![](./Assets/FountainModel.png)

- ###### 喷泉模型的适用情况:

  - 喷泉”这个词体现了面向对象软件开发过程迭代和无缝的特性。迭代是软件开发过程中普遍存在的一种内在属性。用面向对象方法学开发软件时，工作重点应该放在生命周期中的分析阶段。





#### 敏捷过程

---

> 敏捷过程为了使软件开发团队具有高效工作和快速响应变化的能力

- ###### 敏捷过程的四个价值观声明:

  - 个体和交互胜过过程和工具；
  - 可以工作的软件胜过面面俱到的文档；
  - 客户合作胜过合同谈判；
  - 响应变化胜过遵循计划。





#### 极限编程

---

> - 极限编程（eXtreme Programming,XP）是敏捷过程中最富盛名的一个，其名称中“极限”二字的含义是指把好的开发实践运用到极致。
> - 目前，极限编程已经成为一种典型的开发方法，广泛应用于需求模糊且经常改变的场合。

- ###### 极限编程的有效实践:

  - 客户作为开发团队的成员；
  - 使用用户素材；
  - 短交付周期；
  - 验收测试；
  - 结对编程；
  - 测试驱动开发；
  - 集体所有；
  - 持续集成；
  - 可持续的开发速度；
  - 开放的工作空间；
  - 及时调整计划；
  - 简单的设计；
  - 重构；
  - 使用隐喻。

- ###### 敏捷过程的适用情况:

  - 能较好地适应商业竞争环境下对小型项目提出的有限资源和有限开发时间的约束。







## 可行性研究



#### 可行性研究的任务

---

> 可行性研究的目的不是解决问题，而是确定问题是否值得去解决。

- ###### 可行性研究分析过程：

  - 进一步分析和澄清问题定义
  - 分析员应该导出系统的逻辑模型
  - 探索若干种可供选择的主要解法

- ###### 至少应该从下述3个方面研究每种解法的可行性

  - 技术可行性
  - 经济可行性
  - 操作可行性





#### 可行性研究过程

---

> 典型的可行性研究过程有下述8个步骤: 
>
> 1. 复查系统规模和目标；
> 2. 研究目前正在使用的系统；
> 3. 导出新系统的高层逻辑模型；
> 4. 进一步定义问题；
> 5. 导出和评价供选择的解法；
> 6. 推荐行动方针；
> 7. 草拟开发计划书；
> 8. 写文档提交评审

- ###### 复查系统规模和目标

  - 分析员访问关键人员，仔细阅读和分析有关的材料，以便对问题定义阶段书写的关于规模和目标的报告书进一步复查确认，改正含糊或不确切的叙述，清
    晰地描述对目标系统的一切限制和约束。这个步骤的工作，实质上是为了确保分析员正在解决的问题确实是要求他解决的问题。

- ###### 研究目前正在使用的系统

  - 现有的系统是信息的重要来源。显然，如果目前有一个系统正被人使用，那么这个系统必定能完成某些有用的工作，因此，新的目标系统必须也能完成
    它的基本功能；另一方面，如果现有的系统是完美无缺的，用户自然不会提出开发新系统的要求，因此，现有的系统必然有某些缺点，新系统必须能解决旧系统中存在的问题。
  - 应该仔细阅读分析现有系统的文档资料和使用手册，也要实地考察现有的系统。
  - 常见的错误做法是花费过多时间去分析现有的系统。
  - 没有一个系统是在“真空”中运行的，绝大多数系统都和其他系统有联系。

- ###### 导出新系统的高层逻辑模型:

  - 优秀的设计过程通常是从现有的物理系统出发，导出现有系统的逻辑模型，再参考现有系统的逻辑模型，设想目标系统的逻辑模型，最后根据目标系统的逻辑模型建造新的物理系统

- ###### 进一步定义问题:

  - 可行性研究的前4个步骤实质上构成一个循环。分析员定义问题，分析这个问题，导出一个试探性的解；在此基础上再次定义问题，再一次分析这个问题，修改这个解；继续这个循环过程，直到提出的逻辑模型完全符合系统目标

- ###### 导出和评价供选择的解法:

  - 分析员应该从他建议的系统逻辑模型出发，导出若干个较高层次的物理解法供比较和选择。
  - 其次可以考虑操作方面的可行性。分析员应该根据使用部门处理事务的原则和习惯检查技术上可行的那些方案，去掉其中从操作方式或操作过程的角度看用户不能接受的方案。
  - 接下来应该考虑经济方面的可行性。分析员应该估计余下的每个可能的系统的开发成本和运行费用，并且估计相对于现有的系统而言这个系统可以节省的开支或可以增加的收入。
  - 最后为每个在技术、操作和经济等方面都可行的系统制定实现进度表，这个进度表不需要制定得很详细，通常只需要估计生命周期每个阶段的工作量。

- ###### 推荐行动方针:

  - 根据可行性研究结果应该决定的一个关键性问题是： 是否继续进行这项开发工程？分析员必须清楚地表明他对这个关键性决定的建议。如果分析员认为值得继续进行这项开发工程，那么他应该选择一种最好的解法，并且说明选择这个解决方案的理由。通常客户主要根据经济上是否划算决定是否投资于一项开发工程，因此分析员对于所推荐的系统必须进行比较仔细的成本/效益分析

- ###### 草拟开发计划:

  - 分析员应该为所推荐的方案草拟一份开发计划，除了制定工程进度表之外还应该估计对各类开发人员和各种资源的需要情况，应该指明什么时候使用以及使用多长时间。此外还应该估计系统生命周期每个阶段的成本。最后应该给出下一个阶段(需求分析)的详细进度表和成本估计

- ###### 书写文档提交审查

  - 应该把上述可行性研究各个步骤的工作结果写成清晰的文档，请用户、客户组织的负责人及评审组审查，以决定是否继续这项工程及是否接受分析员推荐的方案





#### 成本/效益分析

---

> ![](./Assets/CostBenefitAnalysis.png)

- ###### 估算软件规模常用技术: 代码行技术 功能点技术

- ###### 代码行技术: 定量估算软件规模方法，估计实现一个功能所需要的源程序行数（LOC或KLOC）。

  - 为了使对程序规模的估计更接近实际值，可以由多名有经验的软件工程师分别作出估计。

    每个人估计程序的最小规模（a）、最大规模（b）和最可能规模（m），则程序规模的估计值为：
    $$
    L = \frac{\overline{a} + 4\overline{m} + \overline{b}}{6}
    $$

    > 用代码行技术估算软件规模时，当程序较小时常用的单位是代码行数（LOC），当程序较大时常用的单位是千行代码数（KLOC）。
    >
    > 代码行技术的主要优点是:
    >
    > - 代码是所有软件开发项目都有的“产品”，而且很容易计算代码行数。
    >
    > 代码行技术的缺点是：
    >
    > 1. 源程序仅是软件配置的一个成分，用它的规模代表整个软件的规模似乎不太合理；
    > 2. 用不同语言实现同一个软件所需要的代码行数并不相同；
    > 3.  这种方法不适用于非过程语言。



- ###### 功能点技术: 对软件信息域特性和软件复杂性的评估结果，估算软件规模。用功能点（FP）为单位度量。



- ###### 估算工作量常用技术(面向KLOC的估算模型, 面向FP的估算模型)

  - 软件估算模型使用由经验导出的公式来预测软件开发工作量，工作量是软件规模（KLOC或FP）的函数，工作量的单位通常是人月（pm)。

  - 总体结构形式如：
    $$
    E = A + B \times ev^c
    $$

    其中，A、B和C是由经验数据导出的常数，E是以人月为单位的工作量，ev是估算变量（KLOC或FP）。

  - 面向KLOC的常用估算模型: 
    Walston_Felix模型: 
    $$
    E= 5.2 + (KLPC)^{0.91}
    $$
    Bailey_Basili模型
    $$
    E= 5.5 + 0.73 + (KLPC)^{1.16}
    $$
    Boehm简单模型
    $$
    E= 3.2 \times (KLPC)^{1.05}
    $$
    Doty模型（在KLOC>9时适用）
    $$
    E= 5.288 \times (KLPC)^{1.047}
    $$

  - 对于相同的KLOC或FP值，用不同的模型估算将得出不同的结果。

  - 这些模型适用范围有限。

  - 必须根据当前项目的特点选择适用的估算模型，并且根据需要适当地调整（例如修改模型常数）估算模型。

- ###### 估算成本

  - 软件开发成本主要表现为人力消耗(乘以平均工资则得到开发费用)。

  - 成本估计不是精确的科学，因此应该使用几种不同的估计技术以便相互校验。

  - 使用代码行技术估算: 定量估算方法

    根据经验和历史数据估计实现一个功能需要的源程序行数，用每行代码的平均成本乘以行数就可以确定软件的成本。每行代码的平均成本主要取决于软件的复杂度和工资水平



- ###### 估计开发成本、运行费用和新系统将带来的经济效益

  - 运行费用：取决于系统的操作费用（操作员人数，工作时间，消耗的物资等）和维护费用；
  - 经济效益=使用新系统而增加的收入+使用新系统可以节省的运行费用。
  - 以后在进行成本/效益分析时一律假设生命周期为5年。

  > 成本/效益分析方法主要从四个方面考虑: 
  >
  > 1. 货币的时间价值
  > 2. 投资回收期
  > 3. 纯收入
  > 4. 投资回收率

- ###### 货币的时间价值

  - 通常用利率的形式表示货币的时间价值。

  - 假设年利率为i，如果现在存入P元，则n年后可以得到的钱数为：
    $$
    F = P(1 + i)^{n}
    $$

  - 反之，如果n年后能收入F元钱，那么这些钱的现在价值是：
    $$
    P = F / (1 + i)^{n}
    $$
    

- ###### 投资回收期

  - 通常用投资回收期衡量一项开发工程的价值。
  - 所谓投资回收期就是使累计经济效益等于最初投资所需要的时间。
  - 投资回收期仅仅是一项经济指标，为了衡量一项开发工程的价值，还应该考虑其他经济指标。

- ###### 纯收入

  - 衡量工程价值的另一项经济指标是工程的纯收入，也就是在整个生命周期之内系统的累计经济效益（折合成现在值）与投资之差。
  - 纯收入<0，不值得投资；
  - 纯收入=0，从经济观点看这项工程可能是不值得投资的。

- ###### 投资回收

  - 用投资回收率衡量投资效益的大小，并且可以把它和年利率相比较，在衡量工程的经济效益时，它是最重要的参考数据。





#### 进度计划

---

> 把工作量分配给特定的软件工程任务并规定完成各项任务的起止日期，从而将估算出的项目工作量分布于计划好的项目持续期内。
>
> 进度计划将随着时间的流逝而不断演化。
>
> 随着开发小组规模的扩大，个人生产率将下降，以致开发时间与从事开发工作的人数并不成反比关系

- ###### 工程网络

  - 工程网络是制定进度计划时一种常用的图形工具，它能描绘任务分解情况以及每项作业的开始时间和结束时间，此外，它还显式地描绘各个作业彼此间的依赖关系。因此，工程网络是系统分析和系统设计的强有力的工具。
  - 在工程网络中用箭头表示作业(例如，刮旧漆，刷新漆，清理等)，用圆圈表示事件(一项作业开始或结束)。
  - 事件仅仅是可以明确定义的时间点，它并不消耗时间和资源。
  - 作业通常既消耗资源又需要持续一定时间。
  - 画出工程网络之后，系统分析员就可以借助它的帮助估算工程进度了。为此需要在工程网络上增加一些必要的信息。

- ###### 估算工程进度

  > ![](./Assets/EngineeringNetworkDiagram.png)

  - 首先，把每个作业估计需要使用的时间写在表示该项作业的箭头上方。注意，箭头长度和它代表的作业持续时间没有关系，箭头仅表示依赖关系，它上方的数字才表示作业的持续时间。

  - 其次，为每个事件计算下述两个统计数字：最早时刻EET和最迟时刻LET。这两个数字将分别写在表示事件的圆圈的右上角和右下角
  
    > 通常工程网络中第一个事件的最早时刻定义为零，其他事件的最早时刻在工程网络上从左至右按事件发生顺序计算。计算最早时刻EET使用下述3条简单规则。
    >
    > 考虑进入该事件的所有作业。
    > 对于每个作业都计算它的持续时间与起始事件的EET之和。
    > 选取上述和数中的最大值作为该事件的最早时刻EET。
  
    > 按照惯例，最后一个事件(工程结束)的最迟时刻就是它
    > 的最早时刻。其他事件的最迟时刻在工程网络上从右至
    > 左按逆作业流的方向计算。计算最迟时刻LET使用下述3
    > 条规则。
    > 考虑离开该事件的所有作业。
    > 从每个作业的结束事件的最迟时刻中减去该作业的持续时间。
    > 选取上述差数中的最小值作为该事件的最迟时刻LET。

  - 关键路径： 图中有几个事件的最早时刻和最迟时刻相同，这些事件定义了关键路径，在图中关键路径，用粗线箭头表示。 

    关键路径上的事件(关键事件)必须准时发生，组成关键路径的作业(关键作业)的实际持续时间不能超过估计的持续时间，否则工程就不能准时结束。

    工程项目的管理人员应该密切注视关键作业的进展情况，如果关键事件出现的时间比预计的时间晚，则会使最终完成项目的时间拖后；如果希望缩短工期，只有往关键作业中增加资源才会有效果。

  - 不在关键路径上的作业有一定程度的激动余地。
    机动时间=(LEF)结束 — (EET)开始 — 持续时间
    
    





## 需求分析

> 对软件需求的深入理解是软件开发工作获得成功的前提条件
>
> 需求分析的基本任务是准确地回答“**系统必须做什么**”这个问题



#### 需求分析的任务

---

> 软件需求分为：**功能性需求**和**非功能性需求**
>
> 虽然功能需求是对软件系统的一项基本需求，但却**并不是唯一**的需求
>
> 通常对软件系统有下述几方面的综合要求:
>
> - 功能需求
> - 性能需求
> - 可靠性和可用性需求
> - 出错处理需求
> - 接口需求
> - 约束
> - 逆向需求
> - 将来可能提出的要求

- ###### 功能性需求

  - 这方面的需求指定系统**必须**提供的服务。通过需求分析应该划分出系统必须完成的所有功能

- ###### 性能需求

  - 性能需求指定系统必须满足的定时约束或容量约束，通常包括速度(响应时间)、信息量速率、主存容量、磁盘容量、安全性等方面的需求

- ###### 可靠性和可用性需求

  - 可靠性需求定量地指定系统的可靠性，可用性与可靠性密切相关，它量化了用户可以使用系统的程度

- ###### 出错处理需求

  - 这类需求说明系统对环境错误应该怎样响应。例如，如果它接收到从另一个系统发来的违反协议格式的消息，应该做什么?注意，上述这类错误并不是由该应用系统本身造成的

- ###### 接口需求

  - 接口需求描述应用系统与它的环境通信的格式。常见的接口需求有：用户接口需求；硬件接口需求；软件接口需求；通信接口需求

- ###### 约束

  - 设计约束或实现约束描述在设计或实现应用系统时应遵守的限制条件。常见的约束有：精度；工具和语言约束；设计约束；应该使用的标准；应该使用的硬件平台

- ###### 逆向需求

  - 逆向需求说明软件系统不应该做什么。理论上有无限多个逆向需求，人们应该仅选取能澄清真实需求且可消除可能发生的误解的那些逆向需求

- ###### 将来可能提出的要求

  - 应该明确地列出那些虽然不属于当前系统开发范畴，但是据分析将来很可能会提出来的要求。这样做的目的是，在设计过程中对系统将来可能的扩充和修改预做准备，以便一旦确实需要时能比较容易地进行这种扩充和修改



- ###### 需求分析的困难

  - 用户与开发人员很难进行交流
  - 用户的需求是动态变化的
  - 系统变更的代价呈非线性增长

- ###### 需求工程

  - 需求工程是指应用已证实有效技术、方法进行需求分析，确定客户需求，帮助分析人员理解问题并定义目标系统的所有外部特征的一门学科。
  - 需求工程强调需求分析不是一个独立的阶段，而是存在于整个软件过程中，通过进行需求演进活动尽可能满足用户需求

  ```mermaid
  graph TD
  A(软件需求工程)
  A-->B(需求开发)
  A-->C(需求需求管理)
  B-->D(需求获取)
  B-->E(需求建模)
  B-->F(规格说明)
  B-->G(验证)
  ```

- ###### 需求获取

  - 通过与用户交流，对现有系统进行观察及任务分析的基础上，开发、捕获和修订用户需求的过程
  - 需求获取活动可能设计机构中方方面面的人，是一个复杂困难的过程
  - 获取需求的方法: 
    - 访谈；
    - 参观用户的工作流程，观察用户的操作；
    - 向用户群体发调查问卷；
    - 与同行、专家交谈，听取他们的意见；
    - 分析已经存在的同类软件产品，提取需求；
    - 从行业标准、规则中提取需求；
    - 从Internet上搜查相关资料等

- ###### 需求建模

  - 在描述软件需求时，需求分析人员可以借助各种成熟的需求建模工具对用户的需求内容建立模型，保证需求在描述和理解过程中不会失真。
  - 分析阶段所建立的模型不应涉及软件实现细节，因为这样会分散分析人员的注意力，限制软件设计人员为提高软件的质量和效率而选择实现方法放入自由度。
  - 必须理解并描述问题的信息域，根据这条准则应该建立数据模型。
  - 必须定义软件应完成的功能，这条准则要求建立功能模型。
  - 必须描述作为外部事件结果的软件行为，这条准则要求建立行为模型

> ![](./Assets/StructuredAnalysisModel.png)

- ###### 结构化分析核心思想

  - 分解化简问题
  - 物理与逻辑表示分开
  - 进行数据与逻辑抽象

- ###### 结构化分析模型

  - **模型核心：数据字典**

    描述软件使用和产生的所有数据对象

  - **数据模型：实体-联系图**

    描绘数据对象及数据对象之间的关系，是用于建立数据模型的图形

    图中数据对象属性用“**数据对象描述**”表达

  - **功能模型：数据流图表达**

    描绘数据在软件中移动、变换及相应功能。
    图中功能用“**处理规格说明**”表达

  - **行为模型：状态转换图**

    描绘了系统的各种行为模式和在不同状态间转换的方式。
    图中软件控制附加信息用“**控制规格说明**”表达



- ###### 软件需求规格说明是需求分析阶段得出的最主要的文档，也是用户、软件设计人员和软件分析人员之间进行理解和沟通交流的工具

- ###### 需求验证包括**需求评审**和**需求测试**两个部分

- ###### 从哪些方面验证软件需求的正确性

  - 一致性
  - 完整性
  - 现实性
  - 有效性





#### 数据流图

---

> 描绘信息流和数据在软件中流动和被处理的逻辑过程, 是交流信息和分析与设计的工具
>
> 没有任何具体的物理部件
>
> 只需考虑系统必须完成的基本逻辑功能

- ###### 四种基本符号

  - 正方形(正方体): 表示数据的源点或终点
  - 圆角矩形(原型): 代表变换数据的处理
  - 开口矩形(两条平行横线): 代表数据存储
  - 箭头: 表示数据流，即特定数据的流动方向

  > ![](./Assets/AdditionalSymbolsForDataFlowDiagrams.png)







#### 数据字典

---

> 数据字典是关于数据的信息的集合，也就是对数据流图中包含的所有元素的定义的集合
>
> 四类构成元素:
>
> - 数据存储
> - 处理
> - 数据流
> - 数据元素



- ###### 数据存储: 

  - 数据存储名：
  - 简述：存放的是什么数据。
  - 输入数据:
  - 输出数据:
  - 数据文件组成:数据结构。
  - 存储方式:顺序，直接，关键码。
  - 存取频率:

- ###### 处理

  - 处理名:
  - 处理编号:反映该处理的层次
  - 简要描述:加工逻辑及功能简述
  - 输入数据流:
  - 输出数据流:
  - 加工逻辑： 简述加工程序、加工顺序
  - ... ... 

- ###### 数据流

  - 数据流名：
  - 说明：简要介绍作用即它产生的原因和结果。
  - 数据流来源：即该数据流来自何方。
  - 数据流去向：去向何处
  - 数据流组成：数据结构
  - 每个数据量流通量：数据量、流通量

- ###### 数据元素

  - 数据元素名:
  - 类型:数字（离散值、连续值），文字（编码类型）
  - 长度:
  - 取值范围:
  - 相关的数据元素及数据结构：



- ###### 数据字典的用途

  - 数据字典最重要的用途是作为分析阶段的工具；
  - 数据字典中包含的每个数据元素的控制信息是很有价值的；
  - 数据字典是开发数据库的第一步，而且是很有价值的一步。



- ###### 定义数据的方法

  - 顺序
  - 选择
  - 重复
  - 可选

  | 符号     | 含义            | 举例           |
  | -------- | --------------- | -------------- |
  | =        | 等价于 / 定义为 | x = a          |
  | +        | 与 / 连接       | x = a + b      |
  | [ \| ]   | 或 / 选择       | x = [ a \| b ] |
  | m {  } n | 重复 m .. n 次  | x = 1 { a } 5  |
  | (  )     | 可选            | x = a + ( b )  |
  | " "      | 基本数据元素    | x = “0”        |
  | ..       | 范围            | x = “1” .. “9” |

  





#### 状态转换图

---

> 状态转换图(简称为状态图)通过描绘系统的状态及引起系统状态转换的事件，来表示系统的行为。
>
> 状态是任何可以被观察到的系统行为模式，一个状态代表系统的一种行为模式。状态规定了系统对事件的响应方式。
> 状态图既可以表示系统循环运行过程，也可以表示系统单程生命期
>
> 建模步骤：
> 1. 列出产品/系统的所有状态；
> 2. 列出每个状态须执行的动作；
> 3. 确认并绘制出引起状态发生转换的事件；
> 4. 标注初态和终态，并细化状态转换图



- ###### 定义的状态

  - 初态(即初始状态) : 一张状态图中只能有**一个初态**, 用实心圆表示

  - 终态(即最终状态) : 终态则可以有0至多个, 用一对同心圆(内圆为实心圆)表示

  - 事件 : 引起系统做动作或(和)转换状态的控制信息, 箭头表示，箭头上标事件名

    > 事件表达式的语法: 
    >
    > 事件名(参数表) [守卫条件] / 动作表达式
    >
    > - 事件名: 用户与需求人员对事件的命名
    > - 参数表: 事件在触发或者运行时接收的参数
    > - 守卫条件: 事件被触发时必须满足的条件
    > - 动作表达式: 事件在运行过程中伴随的动作

  - 中间状态 : 用圆角矩形表示，可以用两条水平横线把它分成上、中、下3个部分

    - 上面部分为状态的名称，这部分是必须有的
    - 中间部分为状态变量的名字和值，这部分是可选的
    - 下面部分是活动表，这部分也是可选的

  > ![](./Assets/StateTransitionDiagram.png)

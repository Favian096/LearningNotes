package org.packages.Java_Extends_polymorphism;

public class ExtendsAndPolymorphism {
    public static void main(String[] args) {
//        继承(extends), 让一个类与另一个类建立父子关系(内存中开辟另一个区域)
//        (继承后可以使用父类公共的属性和方法)
        /*  子类们共有属性和方法在父类中定义，独有属性和方法在子类自己中定义*/
        People p = new People();
        Students s = new Students();
        s.setName(" J ");
        s.study();
        s.exam();
        /*  注：子类不能继承父类的构造器
         *       子类只能继承一个父类
         *       Java支持多层继承
         *       所有的类都是object的子类*/

        /*  在继承过程中，
                严格来说子类可以继承父类的私有成员方法，但不能访问(无法直接使用)
                子类不能继承父类的静态成员，但可以访问调用(静态成员只在内存中加载一次)
                        (即：共享非继承)
                多层继承时，父类 和 父类的父类 有同名的方法，则会就近调用父类方法*/

        /*  继承之后, 成员的访问遵循就近原则(先在子类找,找不到再找父类),子类可以覆盖父类(override)
                     方法中会优先使用局部变量名;
        *            如果方法中使用子类成员可以使用(this.成员);
        *            如果要使用父类成员,可以使用(super.成员)   --> super表父类*/

        /*  继承之后, 子类的方法重写会覆盖父类方法,
                      可以在子类的方法中添加 super.方法 保留父类方法
                      再继续添加相应子类代码
                      重写方法一定要加@override注释

                      父类的 私有方法 和 静态方法 不能被子类重写(被认为子类的新方法)
                      重写的 名称 形参列表 要与父类一致
                      重写父类方法时 访问权限要大于等于父类(缺省<protected<public)
                      */

        /*  继承之后, 子类中所有的构造器都会默认先访问父类中的无参构造器, 再执行自己
         *             目的是为了确保父类数据已经初始化, 从而继承数据
         *
         *            如果需要访问父类的有参构造器,则可以在子类建一个有参构造器,
         *                    然后再super.(参, 参...)将参数送至父类以完成访问
         *
         *             this(参, 参...) 会调用本类构造器进行数据的初始化
         *             this() 和 super() 都必须在本类构造器的第一行,但不能同时存在
         *                                                      (会多次初始化)*/

        System.out.println("-----------------");
        Students s2 = new Students("JLY", 20);
        /*  注: 如果父类没有无参构造器,子类调用时会报错(最好写完整)*/
        {
//            Java 多态 (同一个行为具有多个不同表现形式或形态的能力)
            /*  实现形式:   父类类型 对象名 = new 子类构造器
             *                 接口 对象名 = new 实现类构造器
             *  即:父子类的自动类型转换        */
            System.out.println("---多态的例子↓---");
            Animals d = new Dog();
            Animals c = new Cat();
            d.call();
            c.call();

            /*  访问特点:
             *       方法调用:编译看左, 运行看右--->编译使用Animals a创建对象,
             *                                    运行使用new Dog() 调用方法
             *
             *       变量调用:编译看左, 运行看左--->编译使用Animals a创建对象,
             *                                    运行使用Animals 的变量
             *       二者不同的原因是 多态侧重行为的不同, 变量相同(方法不同, 值不同)      */

            /*  多态的优势: 右边对象可以实现解耦合(随时替换为另一个子类),
             *              而替换子类实现新功能的同时, 不需要修改原代码
             *
             *  多态产生的问题: 多态下 不能使用 子类的独有行为
             *      故由此---->需要 进行父子类的 强制类型转换----->实现调用子类独有功能
             *
             *  格式      子类 新对象变量 = (子类)原父类型的变量        */
            Dog d_new = (Dog) d;
            d_new.lookdoor();

            /*  为了避免出现强转错误(Cat的c转为d_new)
                通常会加一个判断当前对象的真实类型再来强转*/
            if (c instanceof Cat) {
                Cat c_new = (Cat) c;
                c_new.catch_mouse();
            }
            System.out.println("------------------");
        }

        {
//            案例: 模拟电脑的2个USB, 实现鼠标键盘插入
            System.out.println("======================================");
            Computer c = new Computer("COLORFUL");
            c.start();

            USB k = new Keyboard("怒喵");
            c.installUSB(k);

            USB m = new Mouse("G304");
            c.installUSB(m);

            System.out.println("======================================");

        }

    }
}

package org.packages;

import org.packages.Test.Test1;
import org.packages.Test.Test2;

public class Demo_1 {

    public static void main(String[] args) {


/*    static 用于修饰成员变量和方法,
    表示该成员变量在内存中只储存一份,可以共享访问和修改*/

        /*      注:通常在实施一个 通用功能为目的  才使用 static(比如main方法)*/

//    通常使用    类名.静态成员变量   进行访问使用
        /*  因为, 静态成员变量归属于 类 不属于对象, 所以在内存中只会存储一份
         *         故使用 类名.静态成员变量 来进行
         *   由此,在同一个类中访问 静态成员变量 可以不需要    类名.   直接使用 静态变量名即可*/

        /*  未使用 static 修饰的 成员变量属于各个对象
         *           故使用      对象名.静态成员变量      来进行*/

        /*  静态成员方法(使用static进行修饰), 该方法归属于类, 通常使用 类名.静态方法  访问
         *   也可以用对象访问
         *   由此,在同一个类中访问 静态成员方法 可以不需要    类名.   直接使用 静态方法名即可*/
        /*  未使用static修饰的成员方法, 归属于对象, 只能使用对象进行访问*/
        {
//        注意事项:
//            静态方法 只能访问静态成员变量和方法, 不能 直接访问 实例成员变量和方法(创建对象间接访问)
//            实例方法既可以访问静态成员变量和方法, 也可访问实例成员变量变量和方法
//            静态方法中不可出现 this 关键字
        }

        {
//        static 工具类(类中都是一些静态方法，每个方法都是以一个共同功能为目的)
            /*  抽离共有功能，提高代码复用性
             *   由此看出，工具类 不需要实例化对象，可以将构造器私有化（private）*/
            /*      比如使用 验证码功能 就是一个工具类方法*/

        }

        {
            System.out.println("====static代码块随类加载=====");
//        static  代码块(使用static{}单独括起来的代码块)
            /*  静态代码块   static{...}
             *       随类加载(在方法前), 自动触发, 只执行一次(类加载时作静态数据处理)*/

//        构造代码块 (直接用{}括起来的)
            /*  创建对象调用构造器执行都会执行代码块,并且在构造器执行前执行(初始化实例资源)*/
        }

        {
//        设计模式(Design Pattern)
            /*  简述: 一个问题有多种解法, 其中最优的解法被总结为 设计模式*/

            /*      单例模式        */
            /*  即:只有一个实例对象, 或只能创建一个实例对象(节省内存)*/

            /*  饿汉单例设计模式
             *       用类获取对象时, 对象已经提前创建
             *   步骤: 定义一个静态对象(外界才能获取对象)
             *         构造器私有化(不能再创建对象)
             *      ---->  Test1  */
            Test1 a = Test1.instance;
            Test1 b = Test1.instance;
            //        此处 a 与 b 地址相同(是一个对象)
            System.out.println(a == b);

            /*  懒汉设计模式
             *       真正需要对象时才会创建一个对象
             * 步骤：定义一个静态变量储存一个对象
             *       构造器私有
             *       提供一个返回单例对象的方法
             *     ------>Test2
             * */
            Test2 c = Test2.getInstance();
            Test2 d = Test2.getInstance();
            System.out.println(c == d);
        }

    }

}

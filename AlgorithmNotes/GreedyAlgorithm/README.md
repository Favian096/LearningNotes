## 贪心算法



#### 1. [活动安排问题](./GreedySelector.cpp)

> 存在这样一个活动集合S={a1,a2,a3,a4,...,an}，
>
> 其中每一个活动ai都有一个开始时间si和结束时间fi保证(0≤si<fi)，
>
> 活动ai进行时，那么它占用的时间为[si,fi)。
>
> 现在这些活动**占用一个共同的资源**，就是这些活动会在某一时间段里面进行安排，
>
> 如果两个活动ai和aj的占用时间[si,fi)，[sj,fj)不重叠，那么就说明这两个活动是兼容的(也就是说当si<=fj或者sj<=fi，那么活动ai，aj是兼容的)
>
> > 示例: 活动集合S
> >
> > | i    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
> > | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> > | si   | 1    | 3    | 0    | 5    | 3    | 5    | 6    | 8    | 8    | 2    | 12   |
> > | fi   | 4    | 5    | 6    | 7    | 9    | 9    | 10   | 11   | 12   | 14   | 16   |
>
> > 观察可得兼容子集有{a3,a9,a11}，但是这个并不是最大兼容子集，
> >
> > 因为{a1,a4,a8,a11}也是这个活动的最大兼容子集，于是我们将活动选择问题描述为：
> >
> > **给定一个集合S={a1,a2,a3,...an}，在相同的资源下，求出最大兼容活动的个数。**
>
> > 贪心算法将活动按照**结束时间**进行**从小到大**排序, 挑选出结束时间尽量早的活动，并且满足后一个活动的起始时间晚于前一个活动的结束时间，全部找出这些活动就是最大的相容活动子集合。
> >
> > 基本原理: 依次检查活动i是否与当前已选择的所有活动相容。若相容活动i加入已选择活动的集合中，否则，不选择活动i，而继续下一活动与集合A中活动的相容性。若活动i与之相容，则i成为最近加入集合A的活动，并取代活动j的位置。
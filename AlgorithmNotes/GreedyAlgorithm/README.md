## 贪心算法



#### 1. [活动安排问题](./GreedySelector.cpp)

> 存在这样一个活动集合S={a1,a2,a3,a4,...,an}，
>
> 其中每一个活动ai都有一个开始时间si和结束时间fi保证(0≤si<fi)，
>
> 活动ai进行时，那么它占用的时间为[si,fi)。
>
> 现在这些活动**占用一个共同的资源**，就是这些活动会在某一时间段里面进行安排，
>
> 如果两个活动ai和aj的占用时间[si,fi)，[sj,fj)不重叠，那么就说明这两个活动是兼容的(也就是说当si<=fj或者sj<=fi，那么活动ai，aj是兼容的)
>
> > 示例: 活动集合S
> >
> > | i    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   |
> > | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> > | si   | 1    | 3    | 0    | 5    | 3    | 5    | 6    | 8    | 8    | 2    | 12   |
> > | fi   | 4    | 5    | 6    | 7    | 9    | 9    | 10   | 11   | 12   | 14   | 16   |
>
> > 观察可得兼容子集有{a3,a9,a11}，但是这个并不是最大兼容子集，
> >
> > 因为{a1,a4,a8,a11}也是这个活动的最大兼容子集，于是我们将活动选择问题描述为：
> >
> > **给定一个集合S={a1,a2,a3,...an}，在相同的资源下，求出最大兼容活动的个数。**
>
> > 贪心算法将活动按照**结束时间**进行**从小到大**排序, 挑选出结束时间尽量早的活动，并且满足后一个活动的起始时间晚于前一个活动的结束时间，全部找出这些活动就是最大的相容活动子集合。
> >
> > 基本原理: 依次检查活动i是否与当前已选择的所有活动相容。若相容活动i加入已选择活动的集合中，否则，不选择活动i，而继续下一活动与集合A中活动的相容性。若活动i与之相容，则i成为最近加入集合A的活动，并取代活动j的位置。



#### 2. 算法基本要素

> 贪心算法通过一系列选择来得到问题的解，所做的每个选择都是当前状态下局部最好选择，即贪心选择。
>
> 这种启发式的策略并不总能奏效，但在许多情况下确能达到预期目的。
>
> 对于一个具体问题，要确定它是否具有贪心选择性质，必须证明每步所做的贪心选择最终导致问题的整体最优解
>
> 贪心算法一般有两个重要的性质:
>
> - 弹性选择性质
> - 最优子结构性质

**2.1 弹性选择性质**

> 贪心算法中，仅在当前状态下做出最好选择(局部最优选择), 再去解做出这个选择后产生的相应的子问题。
>
> 贪心算法所做的贪心选择可以依赖以往所做过的选择，但决不依赖将来所做的选择，也不依赖子问题的解, 由于这种差别，动态规划算法通常以自底向上的方式解各子问题，贪心算法则通常以自顶向下的方式进行，以迭代的方式做出相继的贪心选择，每做一次贪心选择，就将所求问题简化为规模更小的子问题。

**2.2 最优子结构性质**

- [**实现背包问题**]()

> 给定n种物品和一个背包。物品i的重量是w，其价值为v，背包的容量为c。与0-1背包问题不同的是: 
>
> 是在选择物品装入背包时，可以选择物品的一部分，而不一定要全部装入背包, 即物品可以分割成任意大小。
>
> > 基本步骤:
> >
> > 计算每种物品单位重量的价值v/weight;
> >
> > 然后依贪心选择策略，将尽可能多的单位重量价值最高的物品装入背包
> >
> > 若将这种物品全部装入背包后，背包内的物品总重量未超过c，
> >
> > 则选择单位重量价值次高的物品并尽可能多地装入背包。以此策略，直到背包装满为止。





#### 3. [最优装载](./OptimalLoading.cpp)

> 有一批集装箱要装上一艘载重量为c的轮船。其中集装箱i的重量为wi。
>
> 最优装载问题要求在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。
>
> 每个集装箱只有装和不装两种状态, 不可分割
>
> > 贪心算法, 即排序后从最轻的开始装



#### 4. [哈|霍夫曼编码]

> 设要编码的字符集为{d1,d2,…,dn},它们出现的频率为{w1，w2，…,wn}，
>
> 应用哈夫曼树构造最优的不等长的由0，1构成的编码方案。
>
> > 哈夫曼树：给定n个权值作为n个叶子结点，构造一棵二叉树，若树的带权路径长度达到最小，则这棵树被称为哈夫曼树。


## 动态规划



#### 1. [矩阵连乘](./matrixChain.cpp)

> 给定n个矩阵{A1,A2,…,An}, 其中Ai与Ai+1 是可乘的i=1,2,…n-1,
> 考察这n个矩阵的连乘积 ： A1A2…An, 确定计算矩阵连乘积的计算次序，使数乘次数最少
>
> 例: 设有四个矩阵A,B,C,D, 它们的维数分别是：
> > A=50×10，B=10×40，C=40×30，D=30×5
>
> 总共有五种完全加括号的方式：
> > | (A((BC)D)) | ((A(BC))D) |
> > | ---------- | ---------- |
> > | (A(B(CD))) | ((AB)(CD)) |
> > | (((AB)C)D) |            |

> ![](./Assets/matrixChain.png)





#### 2. 基本要素

---

##### 2.1 最优子结构性质

- 当问题的最优解包含子问题的最优解时, 该问题具有最优子结构性质
- 以自底向上的方式递归的从子问题的最优解逐步构建出整个问题的最优解

##### 2.2  子问题重叠性质

- 递归算法自顶向下解子问题时, 每次产生的子问题并不总是新问题, 利用子问题的重叠性质, 对每个子问题只解一次并保存结果以便后续使用

##### 2.3 备忘录方法

- 备忘录方法是动态规划的变形, 备忘录方法用表格保存已解决的子问题的答案以便后续使用
- 与动态规划不同的是, 备忘录方法的递归方式是自顶向下的, 动态规划是自底向上的
- 当一个问题的所有子问题都至少需要解一次时, 使用动态规划
- 当问题空间中的部分子问题可不必求解时, 使用备忘录方法





#### 3. [最长公共子序列](./longestCommonSubsequence.cpp)

>子序列是源序列中删去若干元素后得到的序列
>
>如: 源系列 X = { x1, x2, x3, x4, … xn}, 存在递增下标序列 {i1, i2, i3, … ik}
>
>例: X = {A, B, C, B, D, A, B} 的子序列 Z = {B, C, D, B}, 有递增下标为 {2, 3, 5, 7}
>
>若 Z 同时是 X 和 Y 子序列, 则称 Z 是 X 和 Y 的公共子序列
>
>若 Z 是 X 和 Y 的公共子序列中最长的一个, 则称 Z 是 X 和 Y 的最长公共子序列(LCS)
>
>> 求给定 字符序列的最长公共子序列

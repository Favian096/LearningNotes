## 动态规划

#### 1. [矩阵连乘](MatrixChain.cpp)

> 给定n个矩阵{A1,A2,…,An}, 其中Ai与Ai+1 是可乘的i=1,2,…n-1,
> 考察这n个矩阵的连乘积 ： A1A2…An, 确定计算矩阵连乘积的计算次序，使数乘次数最少
>
> 例: 设有四个矩阵A,B,C,D, 它们的维数分别是：
> > A=50×10，B=10×40，C=40×30，D=30×5
>
> 总共有五种完全加括号的方式：
> > | (A((BC)D)) | ((A(BC))D) |
> > | ---------- | ---------- |
> > | (A(B(CD))) | ((AB)(CD)) |
> > | (((AB)C)D) |            |

> ![](Assets/MatrixChain.png)





#### 2. 算法基本要素

---

**2.1 最优子结构性质**

- 当问题的最优解包含子问题的最优解时, 该问题具有最优子结构性质
- 以自底向上的方式递归的从子问题的最优解逐步构建出整个问题的最优解

**2.2 子问题重叠性质**

- 递归算法自顶向下解子问题时, 每次产生的子问题并不总是新问题, 利用子问题的重叠性质, 对每个子问题只解一次并保存结果以便后续使用

**2.3 备忘录方法**

- 备忘录方法是动态规划的变形, 备忘录方法用表格保存已解决的子问题的答案以便后续使用
- 与动态规划不同的是, 备忘录方法的递归方式是自顶向下的, 动态规划是自底向上的
- 当一个问题的所有子问题都至少需要解一次时, 使用动态规划
- 当问题空间中的部分子问题可不必求解时, 使用备忘录方法





#### 3. [最长公共子序列](LongestCommonSubsequence.cpp)

> 子序列是源序列中删去若干元素后得到的序列
>
>如: 源系列 X = { x1, x2, x3, x4, … xn}, 存在递增下标序列 {i1, i2, i3, … ik}
>
>例: X = {A, B, C, B, D, A, B} 的子序列 Z = {B, C, D, B}, 有递增下标为 {2, 3, 5, 7}
>
>若 Z 同时是 X 和 Y 子序列, 则称 Z 是 X 和 Y 的公共子序列
>
>若 Z 是 X 和 Y 的公共子序列中最长的一个, 则称 Z 是 X 和 Y 的最长公共子序列(LCS)
>
>> 求给定 字符序列的最长公共子序列





#### 4. [最大字段和](./MaximumFieldAnd.cpp)

> 给定由n个整数（包含负整数）组成的序列a1,a2,…,an，求该序列子段和的最大值。
>
>当所有整数均为负值时定义其最大子段和为0。
>
>例: 当 (a1,a2, a3, a4, a5,a6) = (-2,11,-4,13,-5,-2) 时，最大子段和为：11-4+13=20
>
>动态规划算法: 遍历数组找到一个正数后连加记录sum, 若和小于0 则遍历下一正数





#### 5. [凸多边形最优三角划分](minWeightTriangulation.cpp)

> 凸多边形即任意两定点有连线(弦)不会落在凸多边形的外部(图1)
> ![](Assets/MinWeightTriangulation.png)
>
> > 多边形划分为互补相交的三角形的**弦**的集合 T 中, 各弦互不相交且 T 已达到最大(任意不在 T 中的弦必与 T 中的某一弦相交), *在有 n 个定点的凸多边形的三角划分中, 恰有 n - 3 条弦和 n - 2 个三角形*
> > 显然, 三角形权值之和 = 弦之和 + 凸多边形边权之和
> > 给定凸多边形 P = {v0, v1, ... vn-1} , 以及边和弦的权值, 求该凸多边形的最优三角划分(最小权值)





#### [6. 多边形游戏](./PolygonMaxima.cpp)

> 有一个由n个顶点构 成的多边形。
>
> 每个顶点被赋予一个整数值，每条边被赋予一个 运算符 “+” 或 “*” 。所有边依次用整数从1到n编号。
>
> > 游戏开始：
> >
> > 第一步: 选择一条边删除（为了防止最终两条边重叠, 此时的多边形变成一条由数值和符号组成的链）；
> > 第二步: 选择的那一条边，以及该边连接的两个顶点V1和V2；
> > 第三步：用一个新的顶点替代上述边和顶点，新顶点的值为V1，V2经过中间的运算符运算后得到的结果；
> > 第四步：重复送代第二步和第三步，直至所有的边都被删除，只剩下一个结点，得到最终运算结果。
> > 求最终的节点值最大





#### [7. 图像压缩](./ImageCompress.cpp)

>图像的由很多个像素点构成，像素点越多分辨率越高，像素的灰度值范围为0~255，也就是需要8bit来存储一个像素的灰度值信息
>如, 一个像素灰度值序列P={1,2,2,2,1,2,60,55,78}, 传输过程中把图像像素点转成序列，而不是直接传输矩阵, 每个像素灰度值都用8bit来存储是非常消耗空间
>
>正常情况下，一幅图像的某一范围内像素点的灰度值是很接近的，表现为一幅图片某一区域颜色相近,可以把一段内的像素用相同的bit数来存储，只需要额外存树每段的长度和bit数即可，这样可以节省很多空间。
>
>> b[i] : 第i段中每个像素的位数，1<=b[i]<=8 , 需要3 bit
>> l[i] : 第i段中像素的个数, 定义1<=l[i]<=255 , 需要8 bit
>> 此外每一段需要额外的 3+8=11 bit来存储段内像素的信息
>
>![](./Assets/ImageCompress.png)





#### [8. 电路布线](./CircuitWiring.cpp)

> ![](./Assets/CircuitWiring.png)
> 我们采用填表格的方式，填表格的规则我们可以从上面的推论中总结出来(序号从0开始)：
>    1.当i=1时，j<n(i),填0，j>=n(i)，填1。
>    2.当i>1时，j<n(i)，填他上方格子上面的数。
>    3.当i>1时，j>=n(i)，比较**上方格子**和**第(i-1,n(i)-1)**个格子的结果**+1**的大小，取较大者填。
>
> | i \ j | 0    | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   |
> | ----- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
> | 0     | \    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    |
> | 1     | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 1    |
> | 2     | 0    | 0    | 0    | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 1    |
> | 3     | 0    | 0    | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
> | 4     | 0    | 0    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    | 1    |
> | 5     | 0    | 0    | 1    | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 2    |
> | 6     | 0    | 1    | 1    | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 2    |
> | 7     | 0    | 1    | 1    | 1    | 1    | 2    | 2    | 2    | 2    | 3    | 3    |
> | 8     | 0    | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 2    | 3    | 3    |
> | 9     | 0    | 1    | 1    | 2    | 2    | 2    | 2    | 2    | 2    | 3    | 4    |
> | 10    | 0    | 1    | 1    | 2    | 2    | 2    | 3    | 3    | 3    | 3    | 4    |





#### 9. [流水作业调度](./)

> n 个作业 { 1, 2, 3, ... n } 要在由两台机器 M1 和 M2 组成的流水线上完成加工
>
> 每个作业加工顺序都是现在 M1 上加工, 然后在 M2 上加工
>
> M1 和 M2 加工作业 i 所需要的时间分别为 ai 和 bi
>
> 目标: 流水作业调度要求确定这 n 个作业的最优加工顺序, 是的从第一个作业在 M1 机器上开始加工, 到最后一个作业在 M2 机器上加工完成所需的时间最少
>
> > 一个最优调度应使机器M1没有空闲时间，且机器M2的空闲时间最少。在一般情况下，机器M2上会有机器空闲和作业积压2种情况。
> >
> > 机器M1开始加工S中作业时，机器M2还在加工其他作业，要等时间t后才可利用。将这种情况下完成S中作业所需的最短时间记为T(S,t)。流水作业调度问题的最优值为T(N,0)。
> >
> > **T(N,0)=min{ai + T(N-{i}, bi)}, i∈N。**
> >
> > **ai：**选一个作业i先加工，在M1的加工时间。
> >
> > **T(N-{i},bi}：**剩下的作业要等bi时间后才能在M2上加工。注意这里函数的定义，因为一开始工作i是随机取的，M1加工完了ai之后，要开始加工bi了，这里M1是空闲的可以开始加工剩下的N-i个作业了，但此时M2开始加工bi，所以要等bi时间之后才能重新利用，对应到上面函数T(s,t)的定义的话，这里就应该表示成T(N-{i},bi), 所以最优解可表示为T(N,0)=min{ai + T(N-{i}, bi)}, i∈N，即我们要枚举所有的工作i，使这个式子取到最小值。
> >
> > 继续分析T(S,t)可得：
> >
> > 　　　**T(S,t)={ai + T(S-{i}, bi+max{t-ai,0})}, i∈S**
> >
> > ![](./Assets/FlowShop.png)
> >
> > 引入 johnson 法则 : 
> >
> > 当且仅当对任意 i < j 有 : **min{ bi, aj } >= min{ bj, ai }** 满足最优调度
> >





#### 10. [01背包问题](0-1KnapsackProblem.cpp)

> 给定 n 个物品和一个容量为 c 的背包，物品的重量是 wi，其价值为 vi
>
> 选择装入背包内的物品，使得装入背包中的物品的总价值最大
>
> 其中，每种物品只有全部装入背包或不装入背包两种选择。
>
>  物品不能分割，不能重复使用





#### 11. [最优二叉搜索树](./OptimalBinarySearchTree.cpp)

> Ｔ是一棵二元树，它或者为空，或者其每个结点含有一个可以比较大小的数据元素，且有：
>
> - Ｔ的左子树的所有元素比根结点中的元素小；
> - Ｔ的右子树的所有元素比根结点中的元素大；
> - Ｔ的左子树和右子树也是二叉搜索树。
>
> > 给定一个n个关键字的已排序的序列K=<k 1 ,k 2 ,…,k n >（ 设k 1 <k 2 <…<k n ），对每个关键字k i ，都有一个概率p i 表示其搜索频率。根据k i和p i 构建一个二叉搜索树T，每个k i 对应树中的一个结点。若搜索对象x等于某个k i ，则一定可以在T中找到结点k i ；若x<k 1 或 x>k n 或 k i <x<k i+1 (1≤i<n), 则在T中将搜索失败。为此引入外部结点d 0 ,d 1 ,…,d n ，用来表示不在K中的值，称为伪结点。这里每个d i 代表一个区间， d 0 表示所有小于k 1 的值， d n 表示所有大于k n 的值，对于i=1,2,…,n-1，d i 表示所有在k i 和k i+1 之间的值。 同时每个d i 也有一个概率qi 表示搜索对象x恰好落入区间d i 的频率。
